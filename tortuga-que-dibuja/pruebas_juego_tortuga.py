# -*- coding: utf-8 -*-
"""pruebas juego tortuga

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vK9QvfQ-IEo0BuDvfCqEp4e7DZeYPIgA

# Sesión 11: Gráficos y rescursión

### [Programación de Computadores](https://sites.google.com/a/unal.edu.co/prog-comp-2019-2/)
### [Universidad Nacional de Colombia](https://www.unal.edu.co)

Este material fue tomado y adaptado del libro How to Think Like a Computer Scientist: Learning with Python 3, Capítulos 15 y 16, 21 (versión en ingles) y Capítulos 12, 13 y 14 (versión en español)

*   http://www.ict.ru.ac.za/Resources/cspw/thinkcspy3/thinkcspy3.pdf
*   https://argentinaenpython.com/quiero-aprender-python/aprenda-a-pensar-como-un-programador-con-python.pdf
*   http://interactivepython.org/courselib/static/thinkcspy/index.html

## Copyright Notice
Copyright (C) Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
Meyers, and Dario Mitchell. Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free Documentation
License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being Forward, Prefaces, and
Contributor List, no Front-Cover Texts, and no Back-Cover Texts. A copy of
the license is included in the section entitled “GNU Free Documentation
License”.
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install tutormagic
# %load_ext tutormagic

"""## 1. Gráficos de Python Turtle
Hay muchos módulos en Python que proporcionan funciones muy potentes que podemos usar en nuestros propios programas. Algunos de estos pueden enviar correos electrónicos o buscar páginas web. Otros nos permiten realizar cálculos matemáticos complejos. En este capítulo presentaremos un módulo que nos permite crear un objeto de datos llamado tortuga que se puede usar para dibujar.

Los gráficos de tortuga, como se sabe, se basan en una metáfora muy simple. Imagina que tienes una tortuga que entiende inglés. Puede decirle a su tortuga que haga comandos simples, como avanzar y girar a la derecha. A medida que la tortuga se mueve, si su cola está abajo tocando el suelo, dibujará una línea (dejará un rastro atrás) mientras se mueve. Si le dices a tu tortuga que levante su cola, todavía puede moverse pero no dejará rastro. Como verá, puede hacer algunos dibujos bastante sorprendentes con esta capacidad simple.

### 1.1 Un primer programa con tortugas
Intentemos un par de líneas de código Python para crear una nueva tortuga y comenzar a dibujar una figura simple como un rectángulo. Nos referiremos a nuestra primera tortuga con el nombre de variable alex, pero recuerde que puede elegir el nombre que desee siempre que siga las reglas de nombramiento de variables.

El programa que se muestra solo dibujará los dos primeros lados del rectángulo. Después de la línea 4 tendrá una línea recta que va desde el centro del lienzo de dibujo hacia la derecha. Después de la línea 6, tendrá un lienzo con una tortuga y un medio rectángulo dibujado. Presiona el botón Ejecutar para probarlo y ver.


**Por motivos de integración de Turtle con Colab, por favor, ejecute el código siempre en https://repl.it/languages/python_turtle**

**Durante el notebook se le mostrará un enlace que lleva a un repl con el código indicado**

[vea acá el código](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator)
"""

import turtle               # Permite usar la librería de tortugas
wn = turtle.Screen()        # Crea una ventana de gráficos
alex = turtle.Turtle()      # Crea una totuga llamada alex
alex.forward(150)           # Hace que alex se mueva 150 unidades adelante (En dirección a la que apunta)
alex.left(90)               # Gira 90 grados en sentido anti-horario
alex.forward(75)            # Completa el segundo lado del rectángulo

"""Aquí hay un par de cosas que deberá comprender sobre este programa.

La primera línea le dice a Python que cargue un módulo llamado turtle. Ese módulo nos brinda dos tipos nuevos que podemos usar: el tipo Tortuga y el tipo Pantalla. La notación turtle.Turtle significa "El tipo de tortuga que se define dentro del módulo de tortuga". (Recuerde que Python distingue entre mayúsculas y minúsculas, por lo que el nombre del módulo, turtle, con una t minúscula, es diferente del tipo Turtle debido a la T mayúscula).

Luego creamos y abrimos lo que el módulo de tortuga llama una pantalla (preferiríamos llamarlo una ventana, o en el caso de esta una web de Python simplemente un lienzo), que asignamos a la variable wn. Cada ventana contiene un lienzo, que es el área dentro de la ventana en la que podemos dibujar.

En la línea 3 creamos una tortuga. La variable alex está hecha para referirse a esta tortuga. Estas tres primeras líneas nos preparan para que estemos listos para hacer algunos dibujos.

En las líneas 4-6, le pedimos al objeto alex que se mueva y gire. Hacemos esto invocando o activando los métodos de alex: estas son las instrucciones a las que todas las tortugas saben cómo responder. Aquí el punto indica que los métodos invocados pertenecen y se refieren al **objeto** alex.

Un objeto puede tener varios métodos (cosas que puede hacer) y también puede tener atributos (a veces se denomina propiedades). Por ejemplo, cada tortuga tiene un atributo de color. La invocación del método alex.color ("rojo") hará que alex sea rojo y la línea que dibuja también será roja.

El color de la tortuga, el ancho de su pluma (cola), la posición de la tortuga dentro de la ventana, en qué dirección está, etc. son parte de su estado actual. Del mismo modo, el objeto de la ventana tiene un color de fondo que forma parte de su estado.

Existen varios métodos que nos permiten modificar los objetos de la ventana y la tortuga. En el siguiente ejemplo, mostramos solo una pareja y solo hemos comentado las líneas que son diferentes del ejemplo anterior. Tenga en cuenta también que hemos decidido llamar a nuestro objeto de tortuga tess:

[repl](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator-1)
"""

import turtle

wn = turtle.Screen()
wn.bgcolor("lightgreen")        # Establece el color del fondo

tess = turtle.Turtle()
tess.color("blue")              # Hace que la tortuga tess sea azul
tess.pensize(3)                 # Establece el grosor de lápiz

tess.forward(50)
tess.left(120)
tess.forward(50)

wn.exitonclick()                # Espera un click del usuario en la ventana para cerrarla

"""La última línea juega un papel muy importante. La variable $wn$ se refiere a la ventana que se muestra. Cuando invocamos su método `exitonclick()`, el programa detiene la ejecución y espera a que el usuario haga clic con el mouse en algún lugar de la ventana. Cuando se produce este evento de clic, la respuesta es cerrar la ventana de la tortuga y salir (detener la ejecución) del programa Python.

Cada vez que ejecutamos este programa, aparece una nueva ventana de dibujo, y permanecerá en la pantalla hasta que hagamos clic en él.

### 1.2 Instancias - Una manada de tortugas
Al igual que podemos tener muchos enteros diferentes en un programa, podemos tener muchas tortugas. Cada uno de ellos es un objeto independiente y llamamos a cada uno una instancia del tipo de tortuga (clase). Cada instancia tiene sus propios atributos y métodos, por lo que alex podría dibujar con una pluma negra delgada y estar en alguna posición, mientras que Tess podría ir en su propia dirección con una pluma rosa gruesa. Entonces, esto es lo que sucede cuando alex completa un cuadrado y Tess completa su triángulo:

[repl](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator-2)
"""

import turtle
wn = turtle.Screen()             # configura la ventana y sus atributos
wn.bgcolor("lightgreen")


tess = turtle.Turtle()           # Crea una tortuga llamada tess y configura sus atributos (por defecto)
tess.color("hotpink")
tess.pensize(5)

alex = turtle.Turtle()           # crea a alex

tess.forward(80)                 # tess comienza a hacer un triángulo
tess.left(120)
tess.forward(80)
tess.left(120)
tess.forward(80)
tess.left(120)                   # completa el triángulo

tess.right(180)                  # Hace girar a tess
tess.forward(80)                 # Hace mover a tess fuera del origen (punto 0,0)

alex.forward(50)                 # Hacer que Alex comience a dibujar un cuadrado
alex.left(90)
alex.forward(50)
alex.left(90)
alex.forward(50)
alex.left(90)
alex.forward(50)
alex.left(90)

wn.exitonclick()

"""Aquí hay algunas observaciones de " How to Think Like a Computer Scientist:":

Hay 360 grados en un círculo completo. Si sumas todos los giros que hace una tortuga, independientemente de los pasos que se hayan producido entre los giros, puedes averiguar fácilmente si suman algún múltiplo de 360. Esto debería convencerte de que Alex está orientado exactamente en la misma dirección que fue cuando fue creado por primera vez. (Las convenciones de geometría tienen 0 grados hacia el este, ¡y ese es el caso aquí también!)
Podríamos haber dejado fuera el último turno para Alex, pero eso no habría sido tan satisfactorio. Si se le pide que dibuje una forma cerrada como un cuadrado o un rectángulo, es una buena idea completar todos los giros y dejar a la tortuga de regreso donde comenzó, mirando hacia la misma dirección en la que comenzó. Esto hace que el razonamiento sobre ¡El programa y la composición de fragmentos de código en programas más grandes son más fáciles para nosotros, los humanos!
Hicimos lo mismo con Tess: ella dibujó su triángulo y giró 360 grados completos. Luego le dimos la vuelta y la apartamos. Incluso la línea en blanco 18 es un indicio de cómo funciona la fragmentación mental del programador: en términos generales, los movimientos de tess se dividieron en "dibujar el triángulo" (líneas 12-17) y luego "alejarse del origen" (líneas 19 y 20).
Uno de los usos clave de los comentarios es registrar su fragmentación mental y grandes ideas. No siempre están explícitos en el código.
Y, uh-huh, dos tortugas pueden no ser suficientes para una manada, ¡pero entiendes la idea!

### 1.3 Unos métodos más de tortuga y observaciones
Aquí hay algunas cosas más que podrían resultarle útiles a medida que escribes programas que usan tortugas.

* Los métodos de tortuga pueden usar ángulos o distancias negativas. Así que `tess.forward (-100)` la moverá hacia atrás, y `tess.left (-30)` la gira hacia la derecha. Además, debido a que hay 360 grados en un círculo, girar 30 a la izquierda lo dejará en la misma dirección en que gira 330 a la derecha. (Sin embargo, la animación en pantalla será diferente. ¡Podrás saber si tess está girando en el sentido de las agujas del reloj o en sentido contrario!). Esto sugiere que no necesitamos los métodos de giro a la izquierda y a la derecha; podríamos ser minimalistas y solo tenemos un método. También hay un método hacia atrás. (Si eres muy nerd, puedes disfrutar diciendo `alex.backward (-100)` para hacer que alex avance)

* Parte de pensar como un científico es comprender mejor la estructura y las relaciones ricas en su campo. Entonces, revisar algunos datos básicos sobre geometría y líneas numéricas, como hemos hecho aquí, es un buen comienzo si vamos a jugar con las tortugas.

* La pluma de una tortuga se puede recoger o dejar. Esto nos permite mover una tortuga a un lugar diferente sin dibujar una línea. Los métodos son arriba y abajo. Tenga en cuenta que los métodos de pluma y pendiente hacen lo mismo:
"""

alex.up()    #levanta el lápiz
alex.forward(100)     # La tortuga se mueve, pero no deja línea
alex.down()   #vuelve a bajar el lápiz

"""* Puedes acelerar o ralentizar la velocidad de animación de la tortuga. (La animación controla la rapidez con que la tortuga gira y avanza). Los ajustes de velocidad se pueden establecer entre 1 (el más lento) y 10 (el más rápido). Pero si establece la velocidad en 0, tiene un significado especial: desactive la animación y vaya lo más rápido posible:"""

alex.speed(10)

"""* Podemos movernos a una posición en espefífico:"""

alex.goto(0,0)

"""* Dibujar un punto (así no tengamos el lapiz abajo):"""

alex.dot()

"""Para ver una lista completa de las funciones de la tortuga, pueden ver este [enlace](http://interactivepython.org/courselib/static/thinkcspy/PythonTurtle/SummaryofTurtleMethods.html)

### 1.4 Ejemplo 1
Vamos a crear una función con Turtle que dibuje una cuadrícula, que reciba como parámetro la tortuga que va a dibujar, la longitud de cada cuadro, la cantidad de cuadros en el eje X, y la cantidad de cuadros en el eje Y:

[repl](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator-3)
"""

import turtle

def dibujarCuadricula(t, l, x, y):
  t.up()
  t.goto(-210,210)
  t.down()
  t.left(t.heading())
  for row in range(y):
    for col in range(x):
      for j in range(4):
        t.forward(l)
        t.right(90)
      t.forward(l)
    t.right(180)
    t.forward(l*x)
    t.left(90)
    t.forward(l)
    t.left(90)




tess = turtle.Turtle()           # crea a tess
tess.color("hotpink")
tess.pensize(5)
tess.speed(10)
dibujarCuadricula(tess,50,5,5)
wn.exitonclick()

"""La idea es simple: dos ciclos, uno para las filas, y otro para las columnas, y en cada posición, dibujar un cuadrado, y moverse a la siguiente posición.

### 1.5 Ejemplo 2
Ahora vamos a hacer que la tortuga haga el gráfico de una función que nosotros entregemos:
Para ellos necesitamos una función que sea `graficar(t, fun, xi, xf, step)` que reciba la tortuga que va a dibujar, la función que deseamos graficar, el x inicial, x final, y cada cuanto queremos un punto:

[repl](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator-4)
"""

import turtle
import math
def graficar(t, fun, xi, xf, step):
  t.up()
  t.goto(xi,0)
  while xi <= xf:
    t.goto(xi*10,fun(xi))
    t.down()
    xi += step


def f(x):
  return math.sin(x)*100


tess = turtle.Turtle()           # crea a tess
tess.color("hotpink")
tess.pensize(5)
tess.speed(10)
graficar(tess, f, -15, 15, 1)

"""En este ejemplo decidimos multiplicar xi por 10, debido a que esas distancias son por pixeles, y cada pixel es muy pequeño.
El funcionamiento es bastante simple, por cada `xi`, sabemos cual es su `f(xi)`, así que podemos ir a dicha posición, y variar `xi` por cada step hasta llegar a `xf`

## 2 Recursión

### 2.1 Qué es recursión?
La recursión es un método para resolver problemas que consiste en dividir un problema en subproblemas cada vez más pequeños hasta que llegue a un problema lo suficientemente pequeño como para poder resolverlo de manera trivial. Por lo general, la recursión implica una función que se llama a sí misma. Si bien puede que no parezca mucho en la superficie, la recursión nos permite escribir soluciones elegantes para problemas que de otra manera podrían ser muy difíciles de programar.

### 2.2 Cálculo de la suma de una lista de números
Comenzaremos nuestra investigación con un problema simple que ya sabe cómo resolver sin usar la recursión. Supongamos que desea calcular la suma de una lista de números como: [1,3,5,7,9]. Una función iterativa que calcula la suma se muestra a continuación. La función utiliza una variable del acumulador (theSum) para calcular un total acumulado de todos los números en la lista comenzando con 0 y agregando cada número en la lista.
"""

def listsum(numList):
    theSum = 0
    for i in numList:
        theSum = theSum + i
    return theSum

print(listsum([1,3,5,7,9]))

"""Pretenda por un minuto que no tiene bucles `while` o `for`. ¿Cómo calcularías la suma de una lista de números? Si fueras matemático, podrías comenzar recordando que la suma es una función que se define para dos parámetros, un par de números. Para redefinir el problema de agregar una lista a agregar pares de números, podríamos reescribir la lista como una expresión completamente entre paréntesis. Tal expresión se ve así:

$$((((1 + 3) +5) +7) +9)$$
También podemos paréntesis de la expresión al revés,

$$(1+ (3+ (5+ (7 + 9))))$$
Tenga en cuenta que el conjunto más interno de paréntesis, (7 + 9), es un problema que podemos resolver sin un bucle o construcciones especiales. De hecho, podemos usar la siguiente secuencia de simplificaciones para calcular una suma final.

$$total = (1+ (3+ (5+ (7 + 9)))) $$
$$total = (1+ (3+ (5 + 16)) $$
$$total = (1+ (3 + 21)) $$
$$total = (1+ 24) $$
$$total = 25$$
¿Cómo podemos tomar esta idea y convertirla en un programa de Python? Primero, replanteamos la suma del problema en términos de listas de Python. Podríamos decir que la suma de la lista numList es la suma del primer elemento de la lista (numList [0]), y la suma de los números en el resto de la lista (numList [1:]). Para expresarlo en una forma funcional:

$$listSum (numList) = first (numList) + listSum (rest (numList))$$

En esta ecuación, primero $(numList)$ devuelve el primer elemento de la lista y rest $(numList)$ devuelve una lista de todo menos el primer elemento. Esto se expresa fácilmente en Python:
"""

# Commented out IPython magic to ensure Python compatibility.
# %%tutor -k -r
# def listsum(numList):
#    if len(numList) == 1:
#         return numList[0]
#    else:
#         return numList[0] + listsum(numList[1:])
# 
# print(listsum([1,3,5,7,9]))
#

"""Hay algunas ideas clave en este listado para mirar. Primero, en la línea 2 estamos verificando si la lista tiene un elemento de longitud. Esta verificación es crucial y es nuestra cláusula de escape de la función. La suma de una lista de longitud 1 es trivial; es sólo el número en la lista. Segundo, en la línea 5 nuestra función se llama a sí misma. Esta es la razón por la que llamamos al algoritmo de lista de listas recursivo. Una función recursiva es una función que se llama a sí misma.

La Figura 1 muestra la serie de llamadas recursivas que se necesitan para sumar la lista [1,3,5,7,9]. Debe pensar en esta serie de llamadas como una serie de simplificaciones. Cada vez que hacemos una llamada recursiva estamos resolviendo un problema menor, hasta que llegamos al punto en que el problema no puede reducirse.

![texto alternativo](http://interactivepython.org/courselib/static/thinkcspy/_images/sumlistIn.png)

Cuando llegamos al punto en que el problema es tan simple como puede ser, comenzamos a juntar las soluciones de cada uno de los pequeños problemas hasta que se resuelva el problema inicial. La Figura 2 muestra las adiciones que se realizan a medida que la suma de listas avanza hacia atrás a través de la serie de llamadas. Cuando la suma de listas regresa del problema superior, tenemos la solución a todo el problema.

![texto alternativo](http://interactivepython.org/courselib/static/thinkcspy/_images/sumlistOut.png)

### 2.3 Las tres leyes de la recursión
Al igual que los robots de Asimov, todos los algoritmos recursivos deben obedecer tres leyes importantes:

1. Un algoritmo recursivo debe tener un caso base.
2. Un algoritmo recursivo debe cambiar su estado y moverse hacia el caso base.
3. Un algoritmo recursivo debe llamarse a sí mismo, recursivamente.
Veamos cada una de estas leyes con más detalle y veamos cómo se usó en el algoritmo de lista. Primero, un caso base es la condición que permite que el algoritmo deje de repetirse. Un caso base suele ser un problema que es lo suficientemente pequeño como para resolverlo directamente. En el algoritmo de lista de referencia, el caso base es una lista de longitud 1.

Para obedecer la segunda ley, debemos hacer arreglos para un cambio de estado que mueva el algoritmo hacia el caso base. Un cambio de estado significa que se modifican algunos datos que utiliza el algoritmo. Por lo general, los datos que representan nuestro problema se reducen de alguna manera. En el algoritmo de lista, nuestra estructura de datos primaria es una lista, por lo que debemos centrar nuestros esfuerzos de cambio de estado en la lista. Dado que el caso base es una lista de longitud 1, una progresión natural hacia el caso base es acortar la lista. Esto es exactamente lo que sucede en la línea 5 cuando llamamos a `listsum` con una lista más corta.

La ley final es que el algoritmo debe llamarse a sí mismo. Esta es la definición misma de recursión. La recursión es un concepto confuso para muchos programadores principiantes. Como programador novato, ha aprendido que las funciones son buenas porque puede tomar un problema grande y dividirlo en problemas más pequeños. Los problemas más pequeños se pueden resolver escribiendo una función para resolver cada problema. Cuando hablamos de recursión, puede parecer que nos estamos hablando en círculos. Tenemos un problema que resolver con una función, ¡pero esa función resuelve el problema llamándose a sí misma! Pero la lógica no es circular en absoluto; La lógica de la recursión es una expresión elegante de resolver un problema al descomponerlo en problemas más pequeños y fáciles.

En el resto de esta clase veremos más ejemplos de recursión. En cada caso, nos centraremos en diseñar una solución a un problema utilizando las tres leyes de la recursión.

### 2.4 Convertir un entero en una cadena en cualquier base
Supongamos que desea convertir un número entero en una cadena en alguna base entre binario y hexadecimal. Por ejemplo, convierta el número entero 10 a su representación de cadena en decimal como "10", o a su representación de cadena en binario como "1010". Si bien hay muchos enfoques que se pueden tomar para resolver este problema, la formulación recursiva del problema es muy elegante.

Veamos un ejemplo concreto utilizando la base 10 y el número 769. Supongamos que tenemos una secuencia de caracteres que corresponde a los primeros 10 dígitos, como `convString = "0123456789"`. Es fácil convertir un número menor de 10 en su equivalente de cadena buscándolo en la secuencia. Por ejemplo, si el número es 9, entonces la cadena es `convString [9] `o "9". Si podemos hacer arreglos para dividir el número 769 en tres números de un solo dígito, 7, 6 y 9, entonces convertirlo en una cadena es simple. Un número menor a 10 suena como un buen caso base.

Saber cuál es nuestra base sugiere que el algoritmo general incluirá tres componentes:

1. Reduzca el número original a una serie de números de un solo dígito.
2. Convierta el número de un solo dígito en una cadena usando una búsqueda.
3. Concatene las cadenas de un solo dígito para formar el resultado final.

El siguiente paso es averiguar cómo cambiar el estado y avanzar hacia el caso base. Ya que estamos trabajando con un número entero, consideremos qué operaciones matemáticas podrían reducir un número. Los candidatos más probables son la división y la resta. Si bien la resta podría funcionar, no está claro qué debemos restar de qué. La división entera con residuos nos da una dirección clara. Veamos qué sucede si dividimos un número por la base a la que intentamos convertir.

Usando la división entera para dividir 769 por 10, obtenemos 76 con un resto de 9. Esto nos da dos buenos resultados. Primero, el resto es un número menor que nuestra base que se puede convertir a una cadena inmediatamente por búsqueda. Segundo, obtenemos un número que es más pequeño que nuestro original y nos mueve hacia el caso base de tener un solo número menos que nuestra base. Ahora nuestro trabajo es convertir 76 a su representación de cadena. Nuevamente usaremos la división entera más el resto para obtener resultados de 7 y 6 respectivamente. Finalmente, hemos reducido el problema a convertir 7, lo que podemos hacer fácilmente ya que satisface la condición de caso base de n <base, donde base = 10. La serie de operaciones que acabamos de realizar se ilustra en la figura Observe que los números que queremos recordar se encuentran en los cuadros restantes a lo largo del lado derecho del diagrama.

![texto alternativo](http://interactivepython.org/courselib/static/thinkcspy/_images/toStr.png)

El código de activación a continuación muestra el código Python que implementa el algoritmo descrito anteriormente para cualquier base entre 2 y 16.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%tutor -k -r
# def toStr(n,base):
#    convertString = "0123456789ABCDEF"
#    if n < base:
#       return convertString[n]
#    else:
#       return toStr(n//base,base) + convertString[n%base]
# 
# print(toStr(10,2))
#

"""Observe que en la línea 3 verificamos el caso base donde n es menor que la base a la que estamos convirtiendo. Cuando detectamos el caso base, dejamos de hacer recursión y simplemente devolvemos la cadena de la secuencia convertString. En la línea 6 satisfacemos tanto la segunda como la tercera ley: haciendo la llamada recursiva y reduciendo el tamaño del problema, utilizando la división.

Vamos a rastrear el algoritmo de nuevo; esta vez convertiremos el número 10 a su representación de cadena base 2 ("1010").

![texto alternativo](http://interactivepython.org/courselib/static/thinkcspy/_images/toStrBase2.png)

La Figura 4 muestra que obtenemos los resultados que estamos buscando, pero parece que los dígitos están en el orden incorrecto. El algoritmo funciona correctamente porque primero hacemos la llamada recursiva en la línea 6, luego agregamos la cadena de representación del resto. Si revertimos el retorno de la búsqueda `convertString` y el retorno de la llamada `toStr`, la cadena resultante sería hacia atrás. Pero al retrasar la operación de concatenación hasta que la llamada recursiva haya regresado, obtenemos el resultado en el orden correcto.

### 2.5 Visualizando Recursion
Algunos problemas son fáciles de resolver usando la recursión; sin embargo, aún puede ser difícil encontrar un modelo mental o una forma de visualizar lo que está sucediendo en una función recursiva. Esto puede dificultar la recursión para las personas. En esta sección veremos cómo usar la recursividad para dibujar algunas imágenes interesantes. Mientras observa que estas imágenes toman forma, obtendrá una nueva perspectiva del proceso recursivo que puede ser útil para consolidar su comprensión de la recursión.

Para nuestro próximo programa vamos a dibujar un árbol fractal. Los fractales provienen de una rama de las matemáticas y tienen mucho en común con la recursión. La definición de un fractal es que cuando lo miras, el fractal tiene la misma forma básica, no importa cuánto lo magnifiques. Algunos ejemplos de la naturaleza son las costas de los continentes, copos de nieve, montañas e incluso árboles o arbustos. La naturaleza fractal de muchos de estos fenómenos naturales hace posible que los programadores generen escenarios de apariencia muy realista para películas generadas por computadora. En nuestro siguiente ejemplo generaremos un árbol fractal.

Para entender cómo funcionará esto, es útil pensar cómo podríamos describir un árbol utilizando un vocabulario fractal. Recuerda que dijimos anteriormente que un fractal es algo que se ve igual en todos los diferentes niveles de ampliación. Si traducimos esto a árboles y arbustos, podríamos decir que incluso una ramita pequeña tiene la misma forma y características que todo un árbol. Usando esta idea, podríamos decir que un árbol es un tronco, con un árbol más pequeño que va hacia la derecha y otro árbol más pequeño hacia la izquierda. Si piensa en esta definición de forma recursiva, significa que aplicaremos la definición recursiva de un árbol a los árboles de izquierda y derecha más pequeños.

Vamos a traducir esta idea a un código Python. El Listado 1 muestra cómo podemos usar nuestra tortuga para generar un árbol fractal. Veamos el código un poco más de cerca. Verás que en las líneas 5 y 7 estamos haciendo una llamada recursiva. En la línea 5 hacemos el llamado recursivo justo después de que la tortuga gire a la derecha 20 grados; Este es el árbol correcto mencionado anteriormente. Luego, en la línea 7, la tortuga hace otra llamada recursiva, pero esta vez después de girar a la izquierda en 40 grados. La razón por la que la tortuga debe girar a la izquierda 40 grados es porque necesita deshacer el giro original de 20 grados hacia la derecha y luego hacer un giro adicional de 20 grados hacia la izquierda para dibujar el árbol de la izquierda. También tenga en cuenta que cada vez que hacemos una llamada recursiva al árbol (`tree`), restamos cierta cantidad del parámetro `branchLen`; Esto es para asegurarse de que los árboles recursivos se vuelven cada vez más pequeños. También debe reconocer la declaración inicial `if` en la línea 2 como una verificación para el caso base de que `BranchLen` sea demasiado pequeño.
"""

#Listado 1
def tree(branchLen,t):
    if branchLen > 5:
        t.forward(branchLen)
        t.right(20)
        tree(branchLen-15,t)
        t.left(40)
        tree(branchLen-10,t)
        t.right(20)
        t.backward(branchLen)

"""El programa completo para este ejemplo de árbol se muestra a continuación. Antes de ejecutar el código, piense en cómo espera que el árbol tome forma. Mira las llamadas recursivas y piensa en cómo se desarrollará este árbol. ¿Se dibujará simétricamente con las mitades derecha e izquierda del árbol tomando forma simultáneamente? ¿Se dibujará el lado derecho primero y luego el lado izquierdo?

[repl](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator-5)
"""

#ejecutar en Repl.it
import turtle

def tree(branchLen,t):
    if branchLen > 5:
        t.forward(branchLen)
        t.right(20)
        tree(branchLen-15,t)
        t.left(40)
        tree(branchLen-15,t)
        t.right(20)
        t.backward(branchLen)

def main():
    t = turtle.Turtle()
    myWin = turtle.Screen()
    t.left(90)
    t.up()
    t.backward(100)
    t.down()
    t.color("green")
    tree(75,t)
    myWin.exitonclick()

main()

"""Observe cómo cada punto de bifurcación en el árbol corresponde a una llamada recursiva, y observe cómo el árbol se dibuja hacia la derecha hasta su ramita más corta, luego se dibuja el lado izquierdo del árbol, pero no al ir lo más a la izquierda posible. Más bien, una vez más, se dibuja todo el lado derecho del árbol izquierdo hasta que finalmente nos abrimos paso hacia la ramita más pequeña de la izquierda.

Este sencillo programa de árbol es solo un punto de partida para usted, y notará que el árbol no parece particularmente realista porque la naturaleza no es tan simétrica como un programa de computadora. Aquí hay algunas ideas sobre cómo explorar algunas opciones interesantes para hacer que su árbol se vea más realista.

### 2.5.2 Sierpinski Triangle
Otro fractal que exhibe la propiedad de la auto-similitud es el triángulo de Sierpinski. En la Figura 3 se muestra un ejemplo. El triángulo de Sierpinski ilustra un algoritmo recursivo de tres vías. El procedimiento para dibujar un triángulo Sierpinski a mano es simple. Comience con un solo triángulo grande. Divide este triángulo grande en cuatro triángulos nuevos conectando el punto medio de cada lado. Ignorando el triángulo del medio que acaba de crear, aplique el mismo procedimiento a cada uno de los tres triángulos de las esquinas. Cada vez que creas un nuevo conjunto de triángulos, aplicas recursivamente este procedimiento a los tres triángulos de esquina más pequeños. Puede continuar aplicando este procedimiento indefinidamente si tiene un lápiz lo suficientemente afilado.

![texto alternativo](http://interactivepython.org/courselib/static/thinkcspy/_images/sierpinski.png)

Dado que podemos continuar aplicando el algoritmo por tiempo indefinido, ¿cuál es el caso base? Veremos que el caso base se establece arbitrariamente como el número de veces que queremos dividir el triángulo en partes. A veces llamamos a este número el "grado" del fractal. Cada vez que hacemos una llamada recursiva, restamos 1 del grado hasta que llegamos a 0. Cuando alcanzamos un grado de 0, dejamos de hacer llamadas recursivas. El código que generó este Triángulo de Sierpinski se muestra a continuación.

[repl](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator-6)
"""

#Ejercutar en Repl.it
import turtle

def drawTriangle(points,color,myTurtle):
    myTurtle.fillcolor(color)
    myTurtle.up()
    myTurtle.goto(points[0][0],points[0][1])
    myTurtle.down()
    myTurtle.begin_fill()
    myTurtle.goto(points[1][0],points[1][1])
    myTurtle.goto(points[2][0],points[2][1])
    myTurtle.goto(points[0][0],points[0][1])
    myTurtle.end_fill()

def getMid(p1,p2):
    return ( (p1[0]+p2[0]) / 2, (p1[1] + p2[1]) / 2)

def sierpinski(points,degree,myTurtle):
    colormap = ['blue','red','green','white','yellow',
                'violet','orange']
    drawTriangle(points,colormap[degree],myTurtle)
    if degree > 0:
        sierpinski([points[0],
                        getMid(points[0], points[1]),
                        getMid(points[0], points[2])],
                   degree-1, myTurtle)
        sierpinski([points[1],
                        getMid(points[0], points[1]),
                        getMid(points[1], points[2])],
                   degree-1, myTurtle)
        sierpinski([points[2],
                        getMid(points[2], points[1]),
                        getMid(points[0], points[2])],
                   degree-1, myTurtle)

def main():
   myTurtle = turtle.Turtle()
   myWin = turtle.Screen()
   myPoints = [[-100,-50],[0,100],[100,-50]]
   sierpinski(myPoints,3,myTurtle)
   myWin.exitonclick()

main()

"""Este programa sigue las ideas descritas anteriormente. Lo primero que hace `sierpinski` es dibujar el triángulo exterior. A continuación, hay tres llamadas recursivas, una para cada uno de los nuevos triángulos de esquina que obtenemos cuando conectamos los puntos medios.

Mire el código y piense en el orden en que se dibujarán los triángulos. Mientras que el orden exacto de las esquinas depende de cómo se especifique el conjunto inicial, supongamos que las esquinas están ordenadas abajo a la izquierda, arriba, abajo a la derecha. Debido a la forma en que la función `sierpinski` se llama a sí misma, `sierpinski` se abre camino hasta el triángulo más pequeño permitido en la esquina inferior izquierda, y luego comienza a rellenar el resto de los triángulos que están trabajando. Luego llena los triángulos en la esquina superior trabajando hacia el triángulo más pequeño y superior. Finalmente, se llena en la esquina inferior derecha, abriéndose camino hacia el triángulo más pequeño en la esquina inferior derecha.

A veces es útil pensar en un algoritmo recursivo en términos de un diagrama de llamadas a funciones. La figura 4 muestra que las llamadas recursivas siempre se hacen a la izquierda. Las funciones activas están delineadas en negro y las llamadas a funciones inactivas están en gris. Cuanto más lejos vayas hacia la parte inferior de la Figura 4, más pequeños serán los triángulos. La función termina de dibujar un nivel a la vez; Una vez que termina con la parte inferior izquierda, se mueve hacia la mitad inferior, y así sucesivamente.

![texto alternativo](http://interactivepython.org/courselib/static/thinkcspy/_images/stCallTree.png)

La función sierpinski se basa en gran medida en la función `getMid`. `getMid` toma como argumentos dos puntos finales y devuelve el punto a medio camino entre ellos. Además, este programa tiene una función que dibuja un triángulo relleno utilizando los métodos `begin_fill` y `end_fill` turtle.

## 3 Ejercicios
1. Haga una función que reciba una lista (que puede contener sub-listas) y retorne la suma de los elementos.
2. Haga una función que dibuje un árbol que se vea como este:  
![tree](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRxyQ_Vv6ya9HqOrwcE5DLgOkSfGpEVwRFXsTlGPxXm2Cp3LdDa)
3. Haga una función que dibuje una sucesion de X círculos contenidos uno en el otro.
4. Haga una función que calcule el n-ésimo término de la sucesión de fibonacci de forma recursiva.
5. Haga una función que dibuje un círculo, sin usar `for`, ni `while`.
6. Haga una función de calcule el factorial de un número $n$ de forma recursiva
"""

#1

def sumrec(lista):
  if lista == []:
    return 0
  else:
    result = 0
    for elem in lista:
      if type(elem) == list:
        result += sumrec(elem)
      else:
        result += elem
    return result

list1 = [4, 3, [2, [1, 5], 6], 7, []]
print(sumrec(list1))

#3
import turtle

def drawCircle(t, r, l):
  if r<= 0:
    return
  for i in range(360):
    t.forward(l)
    t.right(1)
  t.right(90)
  t.up()
  t.forward(l*15)
  t.down()
  t.left(90)
  drawCircle(t, r-1, l-1)

t = turtle.Turtle()
t.speed(1000)
myWin = turtle.Screen()
drawCircle(t,3, 3)
myWin.exitonclick()

"""[repl](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator-7)"""

#4
def fib(n):
  if n < 3:
    return 1;
  return fib(n-1) + fib(n-2)

print(fib(10))

#Tener en cuenta que esta implementación es muuuy lenta.

#5
import turtle

def drawCircle(t):
  actuallyDrawCircle(t,360)

def actuallyDrawCircle(t, r):
  if r<= 0:
    return
  t.forward(1)
  t.right(1)
  actuallyDrawCircle(t, r-1)

t = turtle.Turtle()
t.speed(1000)
myWin = turtle.Screen()
drawCircle(t)
myWin.exitonclick()

"""[repl](https://repl.it/@fffeelipe/GraciousWheatMemoryallocator-8)"""

#6
def fac(n):
  if n <2:
    return 1
  return n*fac(n-1)

print(fac(4))